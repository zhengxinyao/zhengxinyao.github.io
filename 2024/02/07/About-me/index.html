<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Xinyao | Xinyao</title><meta name="author" content="ICT-IPRC"><meta name="copyright" content="ICT-IPRC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="asplos24fall Paper #62 Reviews and Comments &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Xinyao">
<meta property="og:url" content="https://zhengxinyao.github.io/blog/2024/02/07/About-me/index.html">
<meta property="og:site_name" content="Xinyao">
<meta property="og:description" content="asplos24fall Paper #62 Reviews and Comments &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhengxinyao.github.io/blog/myself.png">
<meta property="article:published_time" content="2024-02-07T15:01:19.025Z">
<meta property="article:modified_time" content="2024-02-14T08:03:27.663Z">
<meta property="article:author" content="ICT-IPRC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhengxinyao.github.io/blog/myself.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://zhengxinyao.github.io/blog/2024/02/07/About-me/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Xinyao',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-02-14 16:03:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog/myself.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/blog/" title="Xinyao"><span class="site-name">Xinyao</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-07T15:01:19.025Z" title="发表于 2024-02-07 23:01:19">2024-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-14T08:03:27.663Z" title="更新于 2024-02-14 16:03:27">2024-02-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>asplos24fall Paper #62 Reviews and Comments</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>Paper #62 TensorTEE: Unified Granularity Heterogeneous TEE for Efficient</p>
<p>Secure Collaborative Computing</p>
<p>Review #62A</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>Overall merit</p>
<p>-————</p>
<p>\2. Weak reject</p>
<p>Reviewer expertise</p>
<p>-—————–</p>
<p>\2. Some familiarity</p>
<p>Paper summary</p>
<p>-————</p>
<p>TensorTEE is a unified trusted execution environment for CPU and NPU to enable secure LLM training. TensorTEE uses a unified granularity for the protection mechanisms for data in memory based on the tensor granularity to alleviate some of the challenges in current platforms. To accomplish this change TensorTEE includes an interface in both the NPU and CPU sides to translate cache line granularity memory accesses into tensor granular accesses that synchronize the security metadata.</p>
<p>Strengths</p>
<p>-——–</p>
<p>Secure heterogeneous computing system are an important research direction. </p>
<p>Interesting observation about the granularity incompatibility between CPU and NPU TEEs.</p>
<p>Weaknesses</p>
<p>-———</p>
<p>Limited contributions - delayed MAC verification has been done before.  </p>
<p>Unclear technical descriptions.</p>
<p>Some design choices break the threat model (such as the delayed integrity verification).</p>
<p>Detailed feedback</p>
<p>-—————-</p>
<p>Thank you for submitting your work to ASPLOS. While i appreciate the effort to improve security in LLM training, I am unclear of what exactly TensorTEE is. It may be due to the unclear technical description but as I understand it, TensorTEE simply translates CPU memory accesses into tensor granular accesses synchronizing the metadata for the corresponding data. It is unclear exactly how the synchronization happens, is it just assumed that all cache lines take on the same VN? Is the VN a max or a sum of all the VN? It is not clear how this is done. And in any case it is also not clear how the security of the system is impacted by this change. Changing the granularity of the security metadata makes it so that either more hash collisions are possible and&#x2F;or more VN overflows will exists. Your manuscript does not go over either of these scenarios. </p>
<p>Furthermore, the assumption that you can just create a secure channel between the two devices obviates the need for a system like TensorTEE as one could just imagine the CPU transferring the unprotected data over to the NPU over this secure channel and then just simply leaving it up to the NPU to manage its own security metadata. Something like Graviton with an added secure channel and without the need to encrypt the data. </p>
<p>You claim that one of the challenges of having the MAC be tensor granular is larger delays to verify the data. It is unclear to me why this is the case as usually MAC engines are pipelined and the throughput is the same, regardless of the length of the data. </p>
<p>Delayed MAC verification is not a novel concept and it has been shown to break the threat model. Delayed MAC verification has been proposed in the very early work of secure memory. However, it has been shown that it is not safe to continue operating on values before verification is completed as an attacker could leverage this speculative window to modify other components outside of the trusted boundary with unverified values (see below citations). How are you addressing this type of vulnerability in delayed MAC verification?  </p>
<p>More questions specific to the manuscript:</p>
<ol>
<li><p>in figure 7 what is on the y-axis? this figure is unclear to me. </p>
</li>
<li><p>In section 4.2 in the dataflow description there is a sentence that indicates that the VN may not be correct. Why is this? This detail is not clearly explained. </p>
</li>
<li><p>In section 4.4.2 under the Communication Phase paragraph it says “data corresponding to the address range is directly transferred from the CPU DRAM to the NPU’s DRAM via a direct channel, without involving the CPU and NPU.” How is the data transferred from CPU DRAM to NPU DRAM? Is it over a secure channel? Is a secure channel necessary? How is a man-in-the-middle attack prevented here?</p>
</li>
</ol>
<p>Citations:</p>
<p>[1] G. E. Suh, D. Clarke, B. Gassend, M. Van Dijk, and S. Devadas, “AEGIS: architecture for tamper-evident and tamper-resistant processing,”  International Conference on Supercomputing (ICS) 2003.</p>
<p>[2] W. Shi and H.-H. S. Lee, “Authentication control point and its implications for secure processor design,” International Symposium on Microarchitecture (MICRO) 2006.</p>
<p>[3] B. Rogers, S. Chhabra, M. Prvulovic, and Y. Solihin, “Using address independent seed encryption and bonsai merkle trees to make secure processors os-and performance-friendly,” International Symposium on Microarchitecture (MICRO) 2007.</p>
<p>[4] T.S. Lehman, A.D. Hilton, and B.C. Lee. “PoisonIvy: Safe speculation for secure memory.” International Symposium on Microarchitecture (MICRO) 2016.</p>
<p>Review #62B</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>Overall merit</p>
<p>-————</p>
<p>\3. Weak accept</p>
<p>Reviewer expertise</p>
<p>-—————–</p>
<p>\3. Knowledgeable</p>
<p>Paper summary</p>
<p>-————</p>
<p>The paper proposes an approach for a discrete, heterogeneous TEE which consists of a CPU and a NPU. The approach is evaluated using a cycle-accurate simulator.</p>
<p>Strengths</p>
<p>-——–</p>
<p>+ The paper is very well motivated and the approach is nicely introduced. </p>
<p>+ The approach makes sense and performance evaluation shows very limited overhead using concepts like delayed verification of tensor-granularity MACs </p>
<p>+ Looks like an approach that might be practical</p>
<p>Weaknesses</p>
<p>-———</p>
<p>+ Missing discussion of potential security impacts of the delayed verification</p>
<p>+ Missing impact on flexibility and software by using tensor granularity MACs and VNs</p>
<p>Detailed feedback</p>
<p>-—————-</p>
<p>The paper is well-written and has quite convincing arguments and evaluations. </p>
<p>Still, I wonder about the potential disadvantages of having tensor-granularity MACs and VNs. Does this potentially affect the software that runs on the CPU and how? </p>
<p>Is there a potential for side-channel attacks to have a delayed verification of MACs - since data is used before being verified? If not, why not? </p>
<p>How would this affect non-tensor-based computations on the CPU? Would the performance be affected? Would that software potentially also benefit from a larger VN granularity?</p>
<p>Review #62C</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>Overall merit</p>
<p>-————</p>
<p>\2. Weak reject</p>
<p>Reviewer expertise</p>
<p>-—————–</p>
<p>\3. Knowledgeable</p>
<p>Paper summary</p>
<p>-————</p>
<p>Background:</p>
<p>SGX uses version numbers alongside physical addresses to encrypt memory, and it also uses</p>
<p>Merkle trees to authenticate memory contents.</p>
<p>Assuming that secure LLM training on a CPU + NPU machine requires both to</p>
<p>use SGX-like memory protection, this submission introduces three optimizations</p>
<p>to reduce the overhead of memory protection:</p>
<ol>
<li>CPU memory controller extension that identifies tensors based on core memory</li>
</ol>
<p>accesses and uses a single version number for the entire tensor (MBs);</p>
<ol start="2">
<li><p>lazy tensor MAC verification that reverts computation if MAC verification fails; and</p>
</li>
<li><p>direct NPU access to CPU memory by sharing the same key, version numbers, and tensor encryption.</p>
</li>
</ol>
<p>All of the above, called TensorTEE, are verified using Gem5 simulations that show</p>
<p>up to 6x batch latency reduction for LLM training.</p>
<p>Strengths</p>
<p>-——–</p>
<p>+ Using the same key on both NPU and CPU is a neat idea</p>
<p>Weaknesses</p>
<p>-———</p>
<p>- Worst case scenarios are dismissed too quickly</p>
<p>- Dismisses simpler solutions too quickly</p>
<p>- Applicable only to SGX</p>
<p>Detailed feedback</p>
<p>-—————-</p>
<p>Thank you for submitting your work to ASPLOS’24! I enjoyed reading about</p>
<p>collaborative LLM training using TEEs. I think that aligning tensors between</p>
<p>CPU and NPU makes a lot of sense and that the benefit of using the same</p>
<p>key on both is clear. However, I’m less excited by speculatively identifying</p>
<p>tensors on the memory controller and lazily verifying tensor MAC. I think that</p>
<p>both of these can lead to significant degradation in the worst case, which</p>
<p>unfortunately is not evaluated. Also, I’m disappointed that simpler solutions,</p>
<p>such as not encrypting NPU memory or adding AES engines are dismissed off-hand</p>
<p>despite their prevalence with NVIDIA’s GPUs. Similarly, today’s GPUs support</p>
<p>confidential computing using VMs which side-step the problem tackled by this</p>
<p>paper, and I think that the authors should present the scope of their work more</p>
<p>clearly: applies only to SGX, and make an argument for the pros&#x2F;cons of NPU TEEs</p>
<p>based on this approach. See below in more details:</p>
<p>###  Worst case scenarios are dismissed too quickly</p>
<p>Two worst case scenarios should be discussed and evaluated:</p>
<p>(1) failure to detect a tensor; and</p>
<p>(2) lazy MAC verification failure.</p>
<p>Failure to detect a tensor can happen for several reasons,</p>
<p>including for example context switches on the CPU where</p>
<p>a different process will use the same virtual addresses</p>
<p>as the TensorTEE but this time with a different data structure.</p>
<p>In general, I’m skeptical that the memory controller can</p>
<p>successfully identify CPU data structure without failure.</p>
<p>Lazy MAC verification is considered safe because a rollback mechanism</p>
<p>exists. But, by the time MAC verification is complete, I’m not sure that a</p>
<p>rollback is possible without software involvement. A tensor can be as large as</p>
<p>several MB and as computation continues without verifying this data the CPU</p>
<p>won’t be able to save all this “speculative” state and revert it.</p>
<p>### Dismisses simpler solutions too quickly</p>
<ol>
<li>Is there a need to encrypt NPU memory?</li>
</ol>
<p>It appears that this submission rests on the need to encrypt NPU memory. But</p>
<p>what evidence is there to suggest that NPU memory is unsafe and can be accessed</p>
<p>by a malicious hypervisor or cloud service provider? To make this more specific,</p>
<p>[NVIDIA’s technical blog on confidential computing</p>
<p>explains](<a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/confidential-computing-on-h100-gpus-for-secure-and-trustworthy-ai/">https://developer.nvidia.com/blog/confidential-computing-on-h100-gpus-for-secure-and-trustworthy-ai/</a>)</p>
<p>that: “on-package HBM memory is considered secure against everyday physical</p>
<p>attack tools and is not encrypted”. Is NVIDIA wrong?</p>
<p>Don’t get me wrong, I see that you are not the first to submit a paper in this</p>
<p>space, but I couldn’t find any concrete attacks suggesting that this memory</p>
<p>needs protection and I’ve looked in the references that the authors have</p>
<p>provided.</p>
<p>\1. 内存保护的文章认为on-pakage HBM是安全的，主要针对GDDR等DRAM内存设备。</p>
<p>GPU类例如“Common-counter”和“PSSM”，认为HBM不易受到物理攻击，但是HBM昂贵且目前市场规模较小，很多商用GPU仍然使用GDDRx的内存或者和CPU共享DDR内存，所以GPU TEE的内存保护依旧有意义，需要内存加密保护。MGX，TNPU等进行内存保护也考虑的是DRAM。</p>
<p>“However, Graviton assumes that 3D stacked DRAM such as HBM (High Bandwidth Memory) is available for GPUs, and the data in the 3D stacked DRAM is always safe even from any possible physical attacks. However, many commodity GPUs will still be relying on much less expensive GDDRx memory [33]–[35], vulnerable from physical attacks. In addition, embedded GPUs share the same DDRx memory with CPUs [3], [9], [10]. Considering the wide-spread use of GDDRx and its vulnerability from physical attacks, it is essential to investigate the performance implication of hardware-based memory protection for GPUs.”【Na S, Lee S, Kim Y, et al. Common counters: Compressed encryption counters for secure GPU memory[C]&#x2F;&#x2F;2021 IEEE International Symposium on High-Performance Computer Architecture (HPCA). IEEE, 2021: 1-13.】</p>
<p>“As a result, the device memory is vulnerable to attacks, which may include eavesdropping or tampering of data in memory. Examples include passive eavesdropping between GPU and its device memory [ 32 ], cold boot attacks [ 11 ], rowhammer attacks [21], etc. ”</p>
<p>“Graviton assumes that the GPU device memory is soldered within the GPU package and thus assumes physical attacks on device memory are out of reach. However, due to the high cost of 3D stacked memory, discrete GDDR memory remains to be widely used in commercial GPUs, including the latest Nvidia Am- pere GPUs [2]. Discrete GDDR memory chips are readily accessible as it is a common practice to replace faulty GDDR-memory chips. Thus, GPU device memory will still be vulnerable to physical at- tacks. Moreover, with the new attack scheme like rowhammer [ 21 ]”【Yuan S, Solihin Y, Zhou H. Pssm: Achieving secure memory for gpus with partitioned and sectored security metadata[C]&#x2F;&#x2F;Proceedings of the ACM International Conference on Supercomputing. 2021: 139-151.】</p>
<p>“This paper assumes that GPUs’device memory, specifically, the GDDR memory, is also vulnerable to the physical attacks considered in CPU TEEs. The reason is that GDDR memory is off-chip for GPUs and can be fully exposed to attackers with physical access to the device. Thus, we exclude the GPU GDDR memory modules from the TCB, and assume that the GPU chip forms the security boundary. High bandwidth memory (HBM), however, is not vulnerable to physical attacks if it is soldered within the GPU chip package, and is out of the reach for attackers.”【Yuan S, Awad A, Yudha A W B, et al. Adaptive security support for heterogeneous memory on gpus[C]&#x2F;&#x2F;2022 IEEE International Symposium on High-Performance Computer Architecture (HPCA). IEEE, 2022: 213-228.】</p>
<p>有的文章假设GPU TEE和CPU TEE有一样的内存安全问题，但没有给出假设依据。</p>
<p>“Due to the enormity of the overheads, recent attempts to extend CPU TEE to GPUs [8], [29] ignore the physical attack threats and enlarge the trust base (e.g., adding GPU memory module to the trust base). In contrast, this research assumes the same threat model in CPU TEE also affects GPUs, and assumes that GPU chip provides the security boundary, where all the data stored in the on-chip resources such as registers and caches are safe. The attackers may have physical access to the GPUs hardware, and have the capability to snoop the GPU memory buses or to scan&#x2F;tamper the GPU memory content.”【Yuan S, Yudha A W B, Solihin Y, et al. Analyzing secure memory architecture for gpus[C]&#x2F;&#x2F;2021 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS). IEEE, 2021: 59-69.】</p>
<p>\2. HBM延迟高、带宽大，主要用于GPU、TPU等AI设备，但是HBM成本高扩展难需要封装，目前来看传统的DDR、LPDDR、GDDR以及HBM处于共存的阶段，比如NVIDIA的Grace Hopper 超级芯片。传统的DDR、LPDDR、GDDR以及HBM处于共存的阶段，比如NVIDIA的Grace Hopper 超级芯片，CPU用DDR，GPU用HBM。</p>
<p><img src="E:%5CA-be%20a%20phd%5Clibrary%5Cimage%5Cwps3.jpg" alt="img"> </p>
<p>2017年，AlphaGo再战柯洁，芯片换成了Google自家研发的TPU。在芯片设计上，从第二代开始的每一代TPU，都采用了HBM。英伟达针对数据中心和深度学习的新款GPU Tesla P100，也搭载了第二代HBM内存（HBM2）。高性能计算市场的GPU芯片几乎都配备了HBM内存。</p>
<p>生成式人工智能实现了爆发式发展，国内外大厂争相竞逐AI大模型，大模型训练的过程数据吞吐量很大，HBM成为了AI训练芯片的标配。目前主流的大模型训练芯片A100、H100均应用了HBM，与H100直接竞争的[谷歌TPU v5](<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%B0%B7%E6%AD%8CTPU">https://www.zhihu.com/search?q=谷歌TPU</a> v5&amp;search_source&#x3D;Entity&amp;hybrid_search_source&#x3D;Entity&amp;hybrid_search_extra&#x3D;{:,:3334832220})和AMD MI300即将量产，后两者同样将采用HBM，AWS的Trainium和Inferentia也应用了HBM，并且，Google与AWS正着手研发新一代AI加速芯片，将采用HBM3或HBM3e。</p>
<p><img src="E:%5CA-be%20a%20phd%5Clibrary%5Cimage%5Cwps4.jpg" alt="img"> </p>
<ol start="2">
<li>Arguments against adding more AES engines are weak</li>
</ol>
<p>Now, suppose the need to encrypt was clear, then why not add hardware to</p>
<p>perform this encryption? The CPU already has such hardware, so it should be</p>
<p>possible. The authors argue that this is not the case because:</p>
<p>&gt; The limited AES bandwidth that 8GB&#x2F;s on average […]</p>
<p>&gt; Given the scarcity of resources on the microprocessor die, the integration of</p>
<p>&gt; additional encryption engines (over 1 $mm^2$ per AES unit) into memory</p>
<p>&gt; controllers on the NPU dies poses a prohibitively high cost [17, 66].</p>
<p>But, I don’t buy this argument because (1) the limited bandwidth of a single engine</p>
<p>simply indicates that multiple engines are needed and; (1) the 1 $mm^2$ area claim</p>
<p>is based on stale data from 2010 that showed such an engine can be implemented</p>
<p>on 45 nm technology, which, surely, can shrink significantly on today’s 3nm.</p>
<p>Moreover, the authors also propose quite intrusive CPU changes</p>
<p>### Applicable only to SGX</p>
<p>Versions and Merkle tree based memory protection memory are cool techniques,</p>
<p>but it seems that industry is moving away from these due to their prohibitively</p>
<p>high costs. SGX is the only system that used these.</p>
<p>But, SGX is being replaced by a new generation of VM based</p>
<p>TEEs (Intel TDX, AMD SEV, ARM CCA) that do not use versions or Merkle trees in memory</p>
<p>protection. Furthermore, SGX is being deprecated.</p>
<p>The authors should acknowledge that only SGX is in scope</p>
<p>and that other newer TEE technologies exist, which do not suffer from the</p>
<p>problem addressed by this submission.</p>
<p>#### Narrower scope: LLMs using SGX</p>
<p>Even though running machine learning, including LLMs, inside TEEs is gaining traction.</p>
<p>At the moment, it remains a niche that for now is mainly available through Azure [1].</p>
<p>Moreover, LLMs typically require numerous GPUs working together to train the model.</p>
<p>This implies the need for networking and GPU to GPU communication that should be discussed.</p>
<p>Additionally, this submission is focused on the case where the CPU and NPU collaborate</p>
<p>to train the model and it is unclear how common that is. Namely, the ZeRo-Offload [2]</p>
<p>infrastructure is only one way of training LLMs.</p>
<p>[1] <a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/t5/azure-confidential-computing/unlocking-the-potential-of-privacy-preserving-ai-with-azure/ba-p/3776838">Azure GPU confidential compute</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/atc21-ren-jie.pdf">ZeRO-Offload</a></p>
<p>### Miscellaneous</p>
<p>- In contrast to what is claimed: </p>
<p> &gt; integrated NPU TEE’s performance is limited due to power and area</p>
<p> &gt; constraints, which makes it insufficient for demanding applications such</p>
<p> &gt; as LLM training that involve large computations</p>
<p> Integrated NPUs can work just fine for example, see NVIDIA’s Grace-Hopper.</p>
<p>- Some citations need to be fixed:</p>
<p> &gt; [58] Tobin South, Guy Zuskind, Robert Mahari, and Thomas Hardjono. Secure</p>
<p> &gt; community transformers: Private pooled data for llms.</p>
<p> Is this a whitepaper? Add a link here and elsewhere and&#x2F;or describe where it was</p>
<p> published so it is easier to find.</p>
<p> &gt; Erhu Feng, Xu Lu, Dong Du, Bicheng Yang, Xueqiang Jiang, Yubin Xia, Binyu</p>
<p> &gt; Zang, and Haibo Chen. Scalable memory protection in the {PENGLAI} enclave.</p>
<p> &gt; In 15th {USENIX} Symposium on Operating Systems Design and Implementation</p>
<p> &gt; ({OSDI} 21), pages 275–294, 2021.</p>
<p> Remove the unnecessary {} here and elsewhere</p>
<p>Review #62D</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>Overall merit</p>
<p>-————</p>
<p>\2. Weak reject</p>
<p>Reviewer expertise</p>
<p>-—————–</p>
<p>\2. Some familiarity</p>
<p>Paper summary</p>
<p>-————</p>
<p>This paper targets CPU&#x2F;NPU collaborative ML training, for which both have disjoint memory spaces and are protected with respective TEEs. Under this setting, the data move between the CPU and NPU enclaves can become an overhead. The paper identifies a mismatch between CPU’s cacheline granularity and NPU’s cacheline granularity MAC management. The key idea is therefore a unified tensor-level granularity. The authors further propose delay verification and direct data transfer that optimize the data transfer.</p>
<p>Strengths</p>
<p>-——–</p>
<p>ML with S&amp;P concerns is an interesting design space.</p>
<p>Weaknesses</p>
<p>-———</p>
<p>Target a very specific hardware setting, which narrows the contribution.</p>
<p>Key ideas somewhat incremental </p>
<p>Would be nice to see evaluation on real hardware.</p>
<p>Detailed feedback</p>
<p>-—————-</p>
<p>I appreciate the paper’s fresh perspective towards ML by bringing the data security into consideration. Yet, the system model feels very specific, depending on a number of assumptions: ML training, CPU&#x2F;GPU collaboration, and a discrete NPU card. Removal of any assumption seems to make the problem go away (e.g. NPU only ML, or integrated CPU&#x2F;NPU). I cannot see such a scenario does not exist (someone wants to train models using Google’s cloud TPUs while not trusting Google for data security?), but it is certainly quite far from the mainstream practice for model training. </p>
<p>The key ideas, while seeming reasonable, feel incremental. It is basically cacheline granularity mismatch and some microscopic optimization for data move. Sorry if I sound too negative, but I could not find some high-level principles that can be taken away. </p>
<p>If the CPU TEE is designed with tensor granularity, does it lose generality in supporting other non-ML applications? How much would the overhead be?</p>
<p>Review #62E</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>Overall merit</p>
<p>-————</p>
<p>\3. Weak accept</p>
<p>Reviewer expertise</p>
<p>-—————–</p>
<p>\3. Knowledgeable</p>
<p>Paper summary</p>
<p>-————</p>
<p>This paper addresses the slowdown that emerges from a virtual TEE being </p>
<p>constructed using a CPU side TEE, that operates on cache line granularity</p>
<p>and pays for fine-grained authenticated encryption, and an NPU side TEE</p>
<p>that operates on tensor granularity – transferring the data from CPU</p>
<p>to NPU adds an overhead of 55%. </p>
<p>The authors propose tensor-granularity</p>
<p>metadata (VN, MAC) management in the CPU to align with the NPU and the </p>
<p>models, simplifies the data transfer between the CPU-NPU to only the </p>
<p>tensor VN and MAC needing to go over a trusted channel, and uses a delayed</p>
<p>MAC computation to check for tensor authenticity so that NPU can proceed</p>
<p>while the CPU has the metadata.</p>
<p>Together, the optimizations bring the overhead of a TEE down to a few </p>
<p>percent slowdown compared to non-secure training.</p>
<p>Strengths</p>
<p>-——–</p>
<p>The paper has a simple idea, to align and increase the granularity of</p>
<p>secure offchip memory to a tensor instead of a cache line level. But </p>
<p>it chases down the implications of this change well and proposes reasonable</p>
<p>edits to TEE construction.</p>
<p>Weaknesses</p>
<p>-———</p>
<p>The experimental setup is a custom construction with closed source cycle accurate</p>
<p>models for the NPU tied to RAMulator connected to a modified GEM5 etc – it would be</p>
<p>great to know how you check for correctness of the timing model.</p>
<p>The tradeoffs vs SoftVN could be explained more clearly.</p>
<p>Detailed feedback</p>
<p>-—————-</p>
<p>Can you please describe why SoftVN’s approach does not scale to a heterogeneous</p>
<p>TEE?</p>
<p>At what scale of algorithms would the proposed on-chip only metadata structures</p>
<p>be insufficient? What needs to be true of the models and training algorithms</p>
<p>for the proposed design to continue to apply?</p>
<p>SGX based TEEs have received complaints for not handling side-, covert-, and </p>
<p>speculative channels – what is the scope of these channels in the proposed</p>
<p>design (e.g., with delayed integrity checks).</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zhengxinyao.github.io/blog">ICT-IPRC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zhengxinyao.github.io/blog/2024/02/07/About-me/">https://zhengxinyao.github.io/blog/2024/02/07/About-me/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhengxinyao.github.io/blog" target="_blank">Xinyao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/blog/myself.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2024/02/25/post1/" title="post1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">post1</div></div></a></div><div class="next-post pull-right"><a href="/blog/2024/02/07/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog/myself.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ICT-IPRC</div><div class="author-info__description">勇攀高峰</div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/2024/02/25/post1/" title="post1">post1</a><time datetime="2024-02-25T08:43:50.000Z" title="发表于 2024-02-25 16:43:50">2024-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/2024/02/07/About-me/" title="无题">无题</a><time datetime="2024-02-07T15:01:19.025Z" title="发表于 2024-02-07 23:01:19">2024-02-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/2024/02/07/hello-world/" title="Hello World">Hello World</a><time datetime="2024-02-07T15:00:13.704Z" title="发表于 2024-02-07 23:00:13">2024-02-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ICT-IPRC</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js?v=4.12.0"></script><script src="/blog/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>